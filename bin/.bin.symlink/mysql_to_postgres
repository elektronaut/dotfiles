#!/usr/bin/env ruby

require "mysql2"
require "pg"
require "pp"

source_db, target_db = ARGV
target_db ||= source_db

unless source_db
  puts "Usage: #{$0} source_db [target_db]"
  exit
end

source = Mysql2::Client.new(
  host: "localhost",
  username: ENV["MYSQL_USER"] || "root",
  password: ENV["MYSQL_PASSWORD"] || nil,
  database: source_db,
  encoding: "utf8mb4",
  collation: "utf8mb4_unicode_ci"
)

target = PG.connect(dbname: target_db)

def coerce_value(type, value)
  if type == "boolean"
    value == 1
  else
    value
  end
end

tables = target.exec("SELECT table_name
                      FROM information_schema.tables
                      WHERE table_schema = 'public'")
               .each_with_object({}) do |row, hash|
  table_name = row.values_at("table_name").first

  hash[table_name] = target.exec_params(
    "SELECT column_name, data_type FROM information_schema.columns
     WHERE table_schema = 'public' AND table_name = $1",
    [table_name]
  ).each_with_object({}) do |col_row, col_hash|
    col_hash[col_row.values_at("column_name").first] = {
      data_type: col_row.values_at("data_type").first
    }
  end
end

tables.each do |table, columns|
  if table == "schema_migrations"
    puts "Skipping table '#{table}'..."
    next
  end

  unless source.query("SHOW TABLES LIKE \"#{table}\"").to_a.any?
    puts "Warning: Source table '#{table}' does not exist, skipping..."
    next
  end

  row_count = source.query("SELECT COUNT(*) AS row_count FROM `#{table}`")
                    .to_a.first["row_count"]
  puts "Converting table '#{table}' (#{row_count} rows)..."
  target.exec("TRUNCATE \"#{table}\" RESTART IDENTITY")

  column_names = columns.keys.map { |k| "\"#{k}\"" }.join(", ")
  placeholders = (1..columns.length).map { |n| "$#{n}" }.join(", ")

  # Copy rows
  source.query("SELECT * FROM `#{table}`").each do |row|
    values = columns.map do |name, opts|
      coerce_value(opts[:data_type], row[name])
    end

    target.exec_params(
      "INSERT INTO \"#{table}\" (#{column_names}) VALUES (#{placeholders})",
      values
    )
  end

  # Update id_seq
  next unless columns.keys.include?("id")
  max_id = target.exec("SELECT MAX(id) AS id FROM \"#{table}\"")
                 .first.values_at("id").first
  next unless max_id
  target.exec(
    "ALTER SEQUENCE \"#{table}_id_seq\" RESTART WITH " +
    (max_id.to_i + 1).to_s
  )
end
